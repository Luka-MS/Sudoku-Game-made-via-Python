import tkinter as tk
from tkinter import messagebox
import random
# Game by Luka-M. S.
# Simple Sudoku generator + GUI using backtracking
# Features:
# - Toolbar (Difficulty: Easy/Medium/Hard) and Restart button
# - 9x9 grid using Entry widgets, keyboard input 1-9
# - "Check" button to validate current board, "Solve" to show solution
# - Puzzle generated by creating a full board then removing cells according to difficulty

BOARD_SIZE = 9
BOX = 3

class Sudoku:
    def __init__(self):
        self.grid = [[0]*BOARD_SIZE for _ in range(BOARD_SIZE)]

    def _is_safe(self, r, c, val):
        # row/col
        for i in range(BOARD_SIZE):
            if self.grid[r][i] == val or self.grid[i][c] == val:
                return False
        # box
        br = (r // BOX) * BOX
        bc = (c // BOX) * BOX
        for i in range(br, br + BOX):
            for j in range(bc, bc + BOX):
                if self.grid[i][j] == val:
                    return False
        return True

    def solve_backtrack(self):
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                if self.grid[r][c] == 0:
                    nums = list(range(1, BOARD_SIZE+1))
                    random.shuffle(nums)
                    for val in nums:
                        if self._is_safe(r, c, val):
                            self.grid[r][c] = val
                            if self.solve_backtrack():
                                return True
                            self.grid[r][c] = 0
                    return False
        return True

    def generate_full(self):
        # create a full valid board
        self.grid = [[0]*BOARD_SIZE for _ in range(BOARD_SIZE)]
        self.solve_backtrack()

    def copy(self):
        s = Sudoku()
        s.grid = [row[:] for row in self.grid]
        return s

    def make_puzzle(self, removals):
        # removals = number of cells to remove
        self.generate_full()
        solution = [row[:] for row in self.grid]
        cells = [(r, c) for r in range(BOARD_SIZE) for c in range(BOARD_SIZE)]
        random.shuffle(cells)
        removed = 0
        for r, c in cells:
            if removed >= removals:
                break
            backup = self.grid[r][c]
            self.grid[r][c] = 0
            # (optional) could check for unique solution but skip for speed
            removed += 1
        return solution

class SudokuGUI:
    def __init__(self, master):
        self.master = master
        master.title('Sudoku')

        self.toolbar = tk.Frame(master)
        self.toolbar.pack(side=tk.TOP, fill=tk.X)

        tk.Button(self.toolbar, text='Restart', command=self.restart).pack(side=tk.LEFT, padx=4, pady=4)
        tk.Label(self.toolbar, text='Difficulty:').pack(side=tk.LEFT, padx=(8,2))
        tk.Button(self.toolbar, text='Easy', command=lambda: self.set_difficulty('easy')).pack(side=tk.LEFT)
        tk.Button(self.toolbar, text='Medium', command=lambda: self.set_difficulty('medium')).pack(side=tk.LEFT)
        tk.Button(self.toolbar, text='Hard', command=lambda: self.set_difficulty('hard')).pack(side=tk.LEFT)

        tk.Button(self.toolbar, text='Check', command=self.check_solution).pack(side=tk.RIGHT, padx=4)
        tk.Button(self.toolbar, text='Solve', command=self.show_solution).pack(side=tk.RIGHT)

        label_author = tk.Label(self.toolbar, text="Game by Luka-M. S.", font=("Arial", 10, "italic"), fg="gray")
        label_author.pack(side=tk.RIGHT, padx=10)

        self.board_frame = tk.Frame(master, padx=10, pady=10)
        self.board_frame.pack()

        self.cells = {}  # (r,c) -> Entry
        self.puzzle = Sudoku()
        self.solution = None
        self.difficulty = 'easy'
        self.removals_map = {'easy': 30, 'medium': 45, 'hard': 55}

        self.create_grid()
        self.restart()

    # Game by Luka-M. S.

    def create_grid(self):
        vcmd = (self.master.register(self.validate_entry), '%P')
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                e = tk.Entry(self.board_frame, width=2, justify='center', font=('Arial', 18), validate='key', validatecommand=vcmd)
                e.grid(row=r, column=c, padx=(0 if c % BOX else 4), pady=(0 if r % BOX else 4))
                e.bind('<FocusIn>', lambda ev, r=r, c=c: self.on_focus(r, c))
                e.bind('<KeyRelease>', lambda ev, r=r, c=c: self.on_key(r, c))
                self.cells[(r,c)] = e

    def validate_entry(self, P):

        if P == '':
            return True
        if len(P) > 1:
            return False
        return P in '123456789'

    def on_focus(self, r, c):
        pass

    def on_key(self, r, c):
        val = self.cells[(r,c)].get()
        if val == '':
            return


    def set_difficulty(self, diff):
        self.difficulty = diff
        self.restart()

    def restart(self):
        removals = self.removals_map.get(self.difficulty, 30)
        self.puzzle = Sudoku()
        self.solution = self.puzzle.make_puzzle(removals)
        # fill entries
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                e = self.cells[(r,c)]
                val = self.puzzle.grid[r][c]
                if val != 0:
                    e.config(state='normal')
                    e.delete(0, tk.END)
                    e.insert(0, str(val))
                    e.config(state='disabled', disabledforeground='black')
                else:
                    e.config(state='normal')
                    e.delete(0, tk.END)
                    e.config(fg='blue')

                    # Game by Luka-M. S.

    def get_user_grid(self):
        g = [[0]*BOARD_SIZE for _ in range(BOARD_SIZE)]
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                txt = self.cells[(r,c)].get()
                g[r][c] = int(txt) if txt.isdigit() else 0
        return g

    def check_solution(self):
        user = self.get_user_grid()
        # check filled
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                if user[r][c] == 0:
                    messagebox.showinfo('Sudoku', 'The board is not completely filled.')
                    return

        if user == self.solution:
            messagebox.showinfo('Sudoku', 'Congratulations â€” correct solution!')
        else:

            mistakes = []
            for r in range(BOARD_SIZE):
                for c in range(BOARD_SIZE):
                    if user[r][c] != self.solution[r][c]:
                        mistakes.append((r,c))
            for (r,c) in mistakes:
                self.cells[(r,c)].config(bg='pink')
            messagebox.showinfo('Sudoku', f'Found {len(mistakes)} incorrect cells. Highlighted in pink.')

    def show_solution(self):
        if not self.solution:
            return
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                e = self.cells[(r,c)]
                e.config(state='normal')
                e.delete(0, tk.END)
                e.insert(0, str(self.solution[r][c]))
                e.config(state='disabled', disabledforeground='black')

if __name__ == '__main__':
    root = tk.Tk()
    app = SudokuGUI(root)
    root.mainloop()

    # Game by Luka-M. S.
